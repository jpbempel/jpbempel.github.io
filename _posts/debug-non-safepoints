# profiling stacktraces bias

# Introduction

I presented in my [previous blog post](https://jpbempel.github.io/2022/03/22/jvm-debug-symbols.html) how debug symbols are generated and used to resolve frames in exception stacktraces. 
Beside exceptions, stacktraces are also used extensively in profilers. The old profiler generation was based on JVMTI GetAllStackTraces Api (or equivalent) with the known issue related to this technique (safepoint bias).
The new one is based on the AsyncGetCallTrace un documented API which does not require to be at safepoint to collect stacktraces.
In this article we will explore the consequence on those profilers to rely on debug symbols resolution described earlier.

# Async-Profiler / Honest profiler

One of the most popular profiler based on `AsyncGetCallTrace` is Async-Profiler by Andrei Pangin. Async-Profiler has different method to trigger ticks for collecting stacktraces:
- Perf events
- `itimer`
- Wall clock (regular interval)

Once the tick is triggered, it calls `AsyncGetCallTrace` which will collect stacktraces even if threads are not at safepoint.

Honest Profiler is using the same call with `itimer`.


# JFR

JDK Flight Recorder, for method sampling, use a timer and at each regular interval pick max 5 Java threads, verify that those threads are executing Java code 
(internal state maintined by the JVM) and collect stacktraces in a very similar way than AsyncGetCallTrace, though they don't share the same code.
No safepoint requires also for JFR which allow to collect at any point of the code.


# Last frame resolution
Once stacktraces are collected, they are resolved against debug symbol emitted by the JVM (interpreter or JIT) as described in my previous post.
If you look at stacktraces, bottom of the stack is just a stack of calls, and as we learned previously, calls are safepoint with all debug information
required to resolve them as a pair of method name and line number.

Only the last frame where the code is currently executed can be anywhere inside a method, including outside of a safepoint. If we are outside a 
safepoint we don't have debug information so we cannot resolve this last frame correctly. 

How JFR & AsyncGetCallTrace manage to get this last frame? is the information accurate? Do we have line number precision?

## Async-Profiler
Async-Profiler as several output formats:
- flamegraph (svg/html)
- text (flat/traces/collapsed)
- JFR

For the first 2, where `AsyncGetCallTrace` is used, you will never see line numbers as the author chose to not process/display them.

![](/assets/2022/06/AP_flamegraph.png)

![](/assets/2022/06/AP_traces.png)

for JFR output, line numbers are transfered/preserved from `AsyncGetCallTrace` to the JFR format. This way we can open the file with JDK Mission Control (JMC) 
to see what line is resolved for the last frame.


## Honest Profiler



## JFR

The recording format allow line number information for each frame

Last frame is the only thing that may be outside of Safepoint.
Jfr format can give line information.
Flamegraph for AsyncProfiler does not give this, but output in JFR can give us the line information.

PC of the last frame need to be resolved to a line debug info. => by default only for Safepoint, except if DebugNonSafepoint activated!


# DebugNonSafepoint
There is an interesting flag that modifiy slightly the behavior described above: `-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints`.  This flag activates the recording of more debug information about PC even if it's not at safepoint. It means we can have a more precise location for stacktraces. It's not affecting exceptions, but profiling tools based on `AsyncGetCallTrace` like [JFR/JMC](https://github.com/openjdk/jmc), [AsyncProfiler](https://github.com/jvm-profiling-tools/async-profiler) or [HonestProfiler](https://github.com/jvm-profiling-tools/honest-profiler).

This flag seems like magic but tough there is some caveat about it. We may have information about stacktraces outside of safepoint, tough, it does not mean it's more accurate about time spent on a method reported by profiling tools. See [JDK-8201516](https://bugs.openjdk.java.net/browse/JDK-8201516) and [JDK-8281677](https://bugs.openjdk.java.net/browse/JDK-8281677).

Beware of the auto-activation (AsyncProfiler via JVMTI or PrintAssembly or CompileCommand)

Example of code without Safepoint, and statistical bias with taht (both AP & JFR)
https://gist.github.com/jpbempel/b40e5081b98d9021116f845d8adf0be1

for noLoopBench, add a very expensive operation without loop of call?

## Perf impact?


## References
 - [https://bugs.openjdk.java.net/browse/JDK-8201516](https://bugs.openjdk.java.net/browse/JDK-8201516)
 - [https://bugs.openjdk.java.net/browse/JDK-8281677](https://bugs.openjdk.java.net/browse/JDK-8281677)
 - [http://psy-lob-saw.blogspot.com/2016/06/the-pros-and-cons-of-agct.html](http://psy-lob-saw.blogspot.com/2016/06/the-pros-and-cons-of-agct.html)




