# profiling stacktraces bias

# Introduction

I presented in my [previous blog post](https://jpbempel.github.io/2022/03/22/jvm-debug-symbols.html) how debug symbols are generated and used to resolve frames in exception stacktraces. 
Beside exceptions, stacktraces are also used extensively in profilers. The old profiler generation was based on JVMTI GetAllStackTraces Api (or equivalent) with the known issue related to this technique (safepoint bias).
The new one is based on the AsyncGetCallTrace un documented API which does not require to be at safepoint to collect stacktraces.
In this article we will explore the consequence on those profilers to rely on debug symbols resolution described earlier.

# Async-Profiler / Honest profiler

One of the most popular profiler based on `AsyncGetCallTrace` is Async-Profiler by Andrei Pangin. Async-Profiler has different method to trigger ticks for collecting stacktraces:
- Perf events
- itimer
- Wall clock


usage of asyncGetCallTrace. Can collect stacktrace outside of Safepoint for walking the stack

# JFR

own mechanism (but very similar to AsyncGetCallTrace) 



# Frame resolution
Last frame is the only thing that may be outside of Safepoint.
Jfr format can give line information.
Flamegraph for AsyncProfiler does not give this, but output in JFR can give us the line information.

PC of the last frame need to be resolved to a line debug info. => by default only for Safepoint, except if DebugNonSafepoint activated!


## DebugNonSafepoint
There is an interesting flag that modifiy slightly the behavior described above: `-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints`.  This flag activates the recording of more debug information about PC even if it's not at safepoint. It means we can have a more precise location for stacktraces. It's not affecting exceptions, but profiling tools based on `AsyncGetCallTrace` like [JFR/JMC](https://github.com/openjdk/jmc), [AsyncProfiler](https://github.com/jvm-profiling-tools/async-profiler) or [HonestProfiler](https://github.com/jvm-profiling-tools/honest-profiler).

This flag seems like magic but tough there is some caveat about it. We may have information about stacktraces outside of safepoint, tough, it does not mean it's more accurate about time spent on a method reported by profiling tools. See [JDK-8201516](https://bugs.openjdk.java.net/browse/JDK-8201516) and [JDK-8281677](https://bugs.openjdk.java.net/browse/JDK-8281677).

Beware of the auto-activation (AsyncProfiler via JVMTI or PrintAssembly or CompileCommand)

Example of code without Safepoint, and statistical bias with taht (both AP & JFR)
https://gist.github.com/jpbempel/b40e5081b98d9021116f845d8adf0be1

for noLoopBench, add a very expensive operation without loop of call?

## Perf impact?


## References
 - [https://bugs.openjdk.java.net/browse/JDK-8201516](https://bugs.openjdk.java.net/browse/JDK-8201516)
 - [https://bugs.openjdk.java.net/browse/JDK-8281677](https://bugs.openjdk.java.net/browse/JDK-8281677)
 - [http://psy-lob-saw.blogspot.com/2016/06/the-pros-and-cons-of-agct.html](http://psy-lob-saw.blogspot.com/2016/06/the-pros-and-cons-of-agct.html)




