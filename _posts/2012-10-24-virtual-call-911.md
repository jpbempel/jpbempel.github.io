# Virtual Call 911
Since we know now [how to print JIT code](https://jpbempel.github.io/2012/10/16/how-to-print-disassembly-from-JIT-code.html) & [how far JIT compiler can optimize byte code](https://jpbempel.github.io/2012/10/09/volatile.html), let's dig how it can optimize the most common use case in Java : a virtual call.

## What is a Virtual Call?
A classic call is just a jump to a specific address where the code of the method resides independently of the class of the object.

A virtual call is more complex: the method to be called is dependent of the class of the object. Each class can have a specific implementation of the method. So the compiler cannot resolve at compile time which implementation it should call. The resolution is based on the underlying class of an instance.

Traditional object oriented languages implement virtual call by putting in each instance of class a pointer to the Virtual Method Table (VMT) which contain all virtual methods defined in the class.

![Virtual Call](assets/2012/10/VirtualCall.png)

So a virtual call needs to:
1. Load the instance 
2. Follow the link to the VMT
3. Jump to the address corresponding of the VMT entry.

For an inherited class, usually, a new VMT is created with inherited methods. For an overridden method, the VMT entry is replaced by the overridden implementation.

## Virtual call in Java
Some OO languages like C++, C#, Delphi (yeah, I have some legacy with this language...) mix classic and virtual methods by marking them with modifiers like virtual & override keywords.
However, in Java, there is no such modifiers, so all methods are virtual by default. Of course except static, private and constructor ones.

Considering what each virtual call implies, we can expect non negligible overhead for each call ! How the JIT can help on this situation ?

## Final
The old fashion way to optimize this kind of calls is to mark methods as final. JIT Compiler is informed that no other classes will extend this class in the future so no other overridden implementation is expected.

Let's verify that with this example:

```java
package com.bempel.sandbox;
 
public class TestJIT
{
    public static void main(String[] args) throws Exception
    {
        MyClass obj = new MyClass();       
        for (int i = 0; i < 10000; i++)
        {
            benchVMethod(obj);
        }
        Thread.sleep(1000);
    }
    
    public static void benchVMethod(MyClass obj)
    {
        obj.vmethod();
    }
     
    private static class MyClass
    {
        public final void vmethod()
        {
            if (System.currentTimeMillis() == 0)
            {
                System.out.println("call to vmethod");
            }
        }
    }
}
```

Executed with JVM arguments:
`-server -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:-Inline`

We get:
```
[Entry Point]
[Disassembling for mach='i386']
[Verified Entry Point]
  # {method} 'benchVMethod' '(Lcom/bempel/sandbox/TestJIT$MyClass;)V' in 'com/bempel/sandbox/TestJIT'
  # parm0:    ecx       = 'com/bempel/sandbox/TestJIT$MyClass'
  #           [sp+0x10]  (sp of caller)
  0x02488fc0: mov    %eax,-0x3000(%esp)
  0x02488fc7: push   %ebp
  0x02488fc8: sub    $0x8,%esp          ;*synchronization entry
                                        ; - com.bempel.sandbox.TestJIT::benchVMethod@-1 (line 17)
  0x02488fce: test   %ecx,%ecx
  0x02488fd0: je     0x02488fe3
  0x02488fd2: nop
  0x02488fd3: call   0x0246d040         ; OopMap{off=24}
                                        ;*invokevirtual vmethod
                                        ; - com.bempel.sandbox.TestJIT::benchVMethod@1 (line 17)
                                        ;   {optimized virtual_call}
  0x02488fd8: add    $0x8,%esp
  0x02488fdb: pop    %ebp
  0x02488fdc: test   %eax,0x110000      ;   {poll_return}
  0x02488fe2: ret
``` 
**Note**: I have used `-XX:-Inline` to avoid confusion in reading disassembly with inline optimization.

As you can see our invokevirtual to vmethod was translated by an "optimized virtual_call" to a specific address, so a classic call.
To be sure we have an optimized virtual call, let's re-activate the inline optimizations:
```
[Disassembling for mach='i386']
[Entry Point]
[Verified Entry Point]
  # {method} 'benchVMethod' '(Lcom/bempel/sandbox/TestJIT$MyClass;)V' in 'com/bempel/sandbox/TestJIT'
  # parm0:    ecx       = 'com/bempel/sandbox/TestJIT$MyClass'
  #           [sp+0x10]  (sp of caller)
  0x02468000: mov    %eax,-0x3000(%esp)
  0x02468007: push   %ebp
  0x02468008: sub    $0x8,%esp          ;*synchronization entry
                                        ; - com.bempel.sandbox.TestJIT::benchVMethod@-1 (line 25)
  0x0246800e: test   %ecx,%ecx
  0x02468010: je     0x02468028         ;*invokevirtual vmethod
                                        ; - com.bempel.sandbox.TestJIT::benchVMethod@1 (line 25)
  0x02468012: call   0x6ddfe3a0         ;*invokestatic currentTimeMillis
                                        ; - com.bempel.sandbox.TestJIT$MyClass::vmethod@0 (line 32)
                                        ; - com.bempel.sandbox.TestJIT::benchVMethod@1 (line 25)
                                        ;   {runtime_call}
  0x02468017: mov    %eax,%ebx
  0x02468019: or     %edx,%ebx
  0x0246801b: je     0x02468035         ;*ifne
                                        ; - com.bempel.sandbox.TestJIT$MyClass::vmethod@5 (line 32)
                                        ; - com.bempel.sandbox.TestJIT::benchVMethod@1 (line 25)
  0x0246801d: add    $0x8,%esp
  0x02468020: pop    %ebp
  0x02468021: test   %eax,0x110000      ;   {poll_return}
  0x02468027: ret 
```
You can see a call the `System.currentTimeMillis` in `benchVMethod`, so, effectively, the vmethod was inlined into benchVMethod. Inlining cannot be perform with regular virtual calls but only on classic calls.
What about removing final modifier? Well the result is strictly the same! Of course, we have only one class and no hierarchy, so let's add more classes:

```java
package com.bempel.sandbox;
 
public class TestJIT
{
    public static void main(String[] args) throws Exception
    {
        MyClass obj = new MyClass();
        MyClass obj2 = new MyClass2();
        MyClass obj3 = new MyClass3();
        MyClass obj4 = new MyClass4();
        MyClass obj5 = new MyClass5();
        for (int i = 0; i < 10000; i++)
        {
            benchVMethod(obj);
            benchVMethod(obj2);
            benchVMethod(obj3);
            benchVMethod(obj4);
            benchVMethod(obj5);
        }
        Thread.sleep(1000);
    }
 
    public static void benchVMethod(MyClass obj)
    {
        obj.vmethod();
    }
 
    private static class MyClass
    {
        public void vmethod()
        {
            if (System.currentTimeMillis() == 0)
            {
                System.out.println("call to MyClass.vmethod");
            }
        }
    }
 
    private static class MyClass2 extends MyClass
    {
        @Override
        public void vmethod()
        {
            if (System.currentTimeMillis() == 0)
            {
                System.out.println("call to MyClass2.vmethod");
            }
        }
    }
 
    private static class MyClass3 extends MyClass
    {
        @Override
        public void vmethod()
        {
            if (System.currentTimeMillis() == 0)
            {
                System.out.println("call to MyClass3.vmethod");
            }
        }
    }
 
    private static class MyClass4 extends MyClass
    {
        @Override
        public void vmethod()
        {
            if (System.currentTimeMillis() == 0)
            {
                System.out.println("call to MyClass4.vmethod");
            }
        }
    }
 
    private static class MyClass5 extends MyClass
    {
        @Override
        public void vmethod()
        {
            if (System.currentTimeMillis() == 0)
            {
                System.out.println("call to MyClass5.vmethod");
            }
        }
    }
}
```
