# Virtual Call 911
Since we know now [how to print JIT code](https://jpbempel.github.io/2012/10/16/how-to-print-disassembly-from-JIT-code.html) & [how far JIT compiler can optimize byte code](https://jpbempel.github.io/2012/10/09/volatile.html), let's dig how it can optimize the most common use case in Java : a virtual call.

## What is a Virtual Call?
A classic call is just a jump to a specific address where the code of the method resides independently of the class of the object.

A virtual call is more complex: the method to be called is dependent of the class of the object. Each class can have a specific implementation of the method. So the compiler cannot resolve at compile time which implementation it should call. The resolution is based on the underlying class of an instance.

Traditional object oriented languages implement virtual call by putting in each instance of class a pointer to the Virtual Method Table (VMT) which contain all virtual methods defined in the class.

![Virtual Call](assets/2012/10/VirtualCall.png)

So a virtual call needs to:
1. Load the instance 
2. Follow the link to the VMT
3. Jump to the address corresponding of the VMT entry.

For an inherited class, usually, a new VMT is created with inherited methods. For an overridden method, the VMT entry is replaced by the overridden implementation.

## Virtual call in Java
Some OO languages like C++, C#, Delphi (yeah, I have some legacy with this language...) mix classic and virtual methods by marking them with modifiers like virtual & override keywords.
However, in Java, there is no such modifiers, so all methods are virtual by default. Of course except static, private and constructor ones.

Considering what each virtual call implies, we can expect non negligible overhead for each call ! How the JIT can help on this situation ?

## Final
The old fashion way to optimize this kind of calls is to mark methods as final. JIT Compiler is informed that no other classes will extend this class in the future so no other overridden implementation is expected.

Let's verify that with this example:

```java
package com.bempel.sandbox;
 
public class TestJIT
{
    public static void main(String[] args) throws Exception
    {
        MyClass obj = new MyClass();       
        for (int i = 0; i < 10000; i++)
        {
            benchVMethod(obj);
        }
        Thread.sleep(1000);
    }
    
    public static void benchVMethod(MyClass obj)
    {
        obj.vmethod();
    }
     
    private static class MyClass
    {
        public final void vmethod()
        {
            if (System.currentTimeMillis() == 0)
            {
                System.out.println("call to vmethod");
            }
        }
    }
}
```

Executed with JVM arguments:
`-server -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:-Inline`
