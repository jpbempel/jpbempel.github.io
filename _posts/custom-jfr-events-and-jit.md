---
layout: default
title: "Custom JFR events and JIT"
---
# Custom JFR events and JIT

## Context

A very nice introduction to JFR as a [presentation](https://www.infoq.com/presentations/monitoring-jdk-jfr/) at QCon San Francisson was done by Mikael Vidstedt. In this talk, Mikael introduces custom JFR events that we can create in Java. He enphasises starting at 24:30 that is the event is not enabled, all the code related to the event is optimized away completely.

Seems like a bold statement, let's verify it.

## Generated custom JFR event

Before getting to the actual test, let's deep into the internal of custom JFR event.

the Hello World example for it (from [Oracle Docs](https://docs.oracle.com/en/java/javase/14/jfapi/creating-and-recording-your-first-event.html)):

```
import jdk.jfr.Event;
import jdk.jfr.Label;
import jdk.jfr.Name;

public class HelloWorldSample {

    @Name("com.oracle.Hello")
    @Label("Hello World!")
    static class Hello extends Event {
        @Label("Message")
        String message;
    }

    public static void main(String... args) {
        Hello event = new Hello();
        event.begin();
        event.message = "Hello world!";
        event.commit();
    }
}
```

the `Hello` event inherits from `jdk.jfr.Event` class:

```
@Enabled(true)
@StackTrace(true)
@Registered(true)
abstract public class Event extends jdk.internal.event.Event {
    protected Event() {
    }

    final public void begin() {
    }

    final public void end() {
    }

    final public void commit() {
    }

    final public boolean isEnabled() {
        return false;
    }

    final public boolean shouldCommit() {
        return false;
    }

    final public void set(int index, Object value) {
    }
}

```

Basically an empty class. So where is the meat?
if we run the example with `-Xlog:jfr* -XX:StartFlightRecording`:

```
[0.667s][info][jfr,system,bytecode] Generated bytecode for class HelloWorldSample$Hello(2187)
``` 


